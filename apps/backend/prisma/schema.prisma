// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")

  // Connection pooling configuration
  // Max 20 connections for optimal performance
  directUrl = env("DATABASE_URL")
}

model User {
  id            String  @id @default(cuid())
  email         String  @unique
  password      String
  name          String?
  role          Role    @default(USER)
  emailVerified Boolean @default(false)
  language      String  @default("fr")

  // Stripe fields
  stripeCustomerId   String?            @unique
  subscriptionStatus SubscriptionStatus @default(NONE)
  subscriptionId     String?            @unique
  planType           PlanType           @default(FREE)
  currentPeriodEnd   DateTime?

  // Audit trail fields
  lastLoginAt DateTime?
  lastLoginIp String?
  loginCount  Int       @default(0)

  // Soft delete
  deletedAt DateTime?

  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  refreshTokens      RefreshToken[]
  verificationTokens VerificationToken[]
  resetTokens        PasswordResetToken[]
  csrfTokens         CsrfToken[]
  subscriptions      Subscription[]
  savedArticles      SavedArticle[]
  summaries          Summary[]
  notes              Note[]
  posts              Post[]

  @@index([deletedAt]) // Performance: filter out deleted users
  @@index([role]) // Performance: admin stats & role filtering
  @@index([emailVerified]) // Performance: filter verified users
  @@index([createdAt]) // Performance: sort by creation date (admin pagination)
  @@index([email, deletedAt]) // Performance: login queries (composite index)
  @@index([role, deletedAt]) // Performance: admin stats (active users by role)
  @@index([emailVerified, deletedAt]) // Performance: admin stats queries (verified + active users)
  @@index([stripeCustomerId]) // Performance: Stripe customer lookups (getOrCreateCustomer)
  @@index([lastLoginAt, role]) // Performance: admin analytics - recent logins by role
  @@index([loginCount(sort: Desc)]) // Performance: admin analytics - most active users
  @@map("users")
}

model RefreshToken {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  revoked   Boolean   @default(false)
  usedAt    DateTime? // Token replay detection: timestamp when token was used for refresh
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([token, revoked])
  @@index([revoked]) // Performance: cleanup job & queries filtering by revoked
  @@index([userId, revoked]) // Performance: getUserActiveTokens queries
  @@index([expiresAt]) // Performance: cleanup job expiration check
  @@index([userId, token])
  @@index([createdAt]) // Performance: sort by creation date
  @@index([expiresAt, revoked]) // Performance: cleanup job composite (expired + revoked filter)
  @@index([token, usedAt]) // Performance: token replay detection queries
  @@map("refresh_tokens")
}

model VerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt]) // Performance: cleanup job expiration check
  @@map("verification_tokens")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt]) // Performance: cleanup job expiration check
  @@map("password_reset_tokens")
}

model CsrfToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt]) // Performance: cleanup job expiration check
  @@map("csrf_tokens")
}

model Subscription {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  stripeSubscriptionId String @unique
  stripePriceId        String
  stripeCustomerId     String

  status   SubscriptionStatus
  planType PlanType

  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd  Boolean   @default(false)
  canceledAt         DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([stripeSubscriptionId])
  // Query: WHERE userId = ? AND status IN ('ACTIVE', 'TRIALING') ORDER BY createdAt DESC
  @@index([userId, status, createdAt(sort: Desc)])
  @@index([stripeCustomerId]) // Performance: webhook queries (find by customer)
  @@index([status]) // Performance: filter by status
  @@index([createdAt]) // Performance: sort subscriptions by date
  @@index([currentPeriodEnd]) // Performance: find expiring subscriptions
  @@index([status, currentPeriodEnd]) // Performance: find expiring subscriptions by status
  @@index([stripeSubscriptionId, status]) // Performance: webhook update queries (composite lookup)
  @@map("subscriptions")
}

enum Role {
  USER
  ADMIN
  MODERATOR
}

enum SubscriptionStatus {
  NONE // No subscription
  ACTIVE // Active subscription
  PAST_DUE // Payment failed
  CANCELED // Canceled
  INCOMPLETE // Initial payment in progress
  TRIALING // Trial period
}

enum PlanType {
  FREE // Free plan
  STARTER // Starter plan (6€/month)
  PRO // Pro plan (15€/month)
}

model Article {
  id          String   @id @default(cuid())
  title       String
  url         String   @unique
  excerpt     String // Short description from RSS feed
  imageUrl    String? // Article image from RSS feed or Open Graph
  source      String // RSS feed name
  tags        String[] // Tags for filtering/categorization
  publishedAt DateTime

  savedBy SavedArticle[]

  createdAt DateTime @default(now())

  @@index([url])
  @@index([source])
  @@index([publishedAt])
  @@map("articles")
}

model SavedArticle {
  id        String  @id @default(cuid())
  userId    String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  articleId String
  article   Article @relation(fields: [articleId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, articleId])
  @@index([userId])
  @@index([articleId])
  @@index([userId, createdAt(sort: Desc)]) // Optimizes pagination queries
  @@map("saved_articles")
}

model Summary {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  title        String?
  coverImage   String? // Cover image URL
  originalText String       @db.Text // Original content (text, URL or PDF)
  summaryText  String       @db.Text // Generated summary
  style        SummaryStyle // SHORT, TWEET, THREAD, etc.
  source       String? // URL or filename
  language     String       @default("fr") // fr | en

  createdAt DateTime  @default(now())
  deletedAt DateTime? // Soft delete - null = active, not null = deleted

  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@index([userId, createdAt])
  @@index([userId, deletedAt]) // Optimizes soft delete queries
  @@index([userId, deletedAt, createdAt(sort: Desc)]) // PERF-002: Pagination with soft delete
  @@index([userId, style, createdAt(sort: Desc)]) // Optimizes filtered queries
  @@index([userId, deletedAt, style, createdAt(sort: Desc)]) // Optimizes queries with deletedAt + style filter
  @@map("summaries")
}

model Note {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  title   String
  content String // Markdown content
  tags    String[] // Array de tags

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete - null = active, not null = deleted

  @@index([userId])
  @@index([userId, updatedAt])
  @@index([userId, createdAt(sort: Desc)]) // PERF-002: List queries sorted by creation date
  @@index([userId, deletedAt]) // Optimizes soft delete queries
  @@index([userId, deletedAt, createdAt(sort: Desc)]) // PERF-002: Pagination with soft delete
  @@map("notes")
}

model Post {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  slug     String  @unique
  title    String
  content  String // Markdown content
  isPublic Boolean @default(false)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete - null = active, not null = deleted

  @@index([slug])
  @@index([userId])
  @@index([isPublic])
  @@index([userId, deletedAt]) // Optimizes soft delete queries
  @@index([userId, isPublic, createdAt(sort: Desc)]) // PERF-002: Public posts list queries
  @@index([isPublic, createdAt(sort: Desc)]) // PERF-002: Global public posts feed
  @@map("posts")
}

enum SummaryStyle {
  SHORT // Résumé court (2-3 phrases)
  TWEET // Format tweet (280 caractères)
  THREAD // Thread Twitter (série de tweets)
  BULLET_POINT // Points clés en liste
  TOP3 // Top 3 des highlights
  MAIN_POINTS // Points principaux détaillés
}

model RSSFeed {
  id          String    @id @default(cuid())
  name        String    @unique
  url         String    @unique
  description String?
  tags        String[]
  active      Boolean   @default(true)
  lastFetchAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([active])
  @@index([lastFetchAt])
  @@map("rss_feeds")
}
